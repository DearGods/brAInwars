/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number };
type MaybeErrorWithCode = ErrorWithCode | null | undefined;

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map();
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map();

/**
 * GameNoWinnerFound: 'Game no winner found'
 *
 * @category Errors
 * @category generated
 */
export class GameNoWinnerFoundError extends Error {
  readonly code: number = 0x1770;
  readonly name: string = "GameNoWinnerFound";
  constructor() {
    super("Game no winner found");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameNoWinnerFoundError);
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new GameNoWinnerFoundError());
createErrorFromNameLookup.set(
  "GameNoWinnerFound",
  () => new GameNoWinnerFoundError(),
);

/**
 * CustomError: 'Custom error message'
 *
 * @category Errors
 * @category generated
 */
export class CustomErrorError extends Error {
  readonly code: number = 0x1771;
  readonly name: string = "CustomError";
  constructor() {
    super("Custom error message");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, CustomErrorError);
    }
  }
}

createErrorFromCodeLookup.set(0x1771, () => new CustomErrorError());
createErrorFromNameLookup.set("CustomError", () => new CustomErrorError());

/**
 * SignerNotCrank: 'Signer not crank'
 *
 * @category Errors
 * @category generated
 */
export class SignerNotCrankError extends Error {
  readonly code: number = 0x1772;
  readonly name: string = "SignerNotCrank";
  constructor() {
    super("Signer not crank");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, SignerNotCrankError);
    }
  }
}

createErrorFromCodeLookup.set(0x1772, () => new SignerNotCrankError());
createErrorFromNameLookup.set(
  "SignerNotCrank",
  () => new SignerNotCrankError(),
);

/**
 * MintNotGameToken: 'Mint not game token'
 *
 * @category Errors
 * @category generated
 */
export class MintNotGameTokenError extends Error {
  readonly code: number = 0x1773;
  readonly name: string = "MintNotGameToken";
  constructor() {
    super("Mint not game token");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, MintNotGameTokenError);
    }
  }
}

createErrorFromCodeLookup.set(0x1773, () => new MintNotGameTokenError());
createErrorFromNameLookup.set(
  "MintNotGameToken",
  () => new MintNotGameTokenError(),
);

/**
 * GameNotPlayersActions: 'Game not players actions'
 *
 * @category Errors
 * @category generated
 */
export class GameNotPlayersActionsError extends Error {
  readonly code: number = 0x1774;
  readonly name: string = "GameNotPlayersActions";
  constructor() {
    super("Game not players actions");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameNotPlayersActionsError);
    }
  }
}

createErrorFromCodeLookup.set(0x1774, () => new GameNotPlayersActionsError());
createErrorFromNameLookup.set(
  "GameNotPlayersActions",
  () => new GameNotPlayersActionsError(),
);

/**
 * GameAlreadyOngoing: 'Game already ongoing'
 *
 * @category Errors
 * @category generated
 */
export class GameAlreadyOngoingError extends Error {
  readonly code: number = 0x1775;
  readonly name: string = "GameAlreadyOngoing";
  constructor() {
    super("Game already ongoing");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameAlreadyOngoingError);
    }
  }
}

createErrorFromCodeLookup.set(0x1775, () => new GameAlreadyOngoingError());
createErrorFromNameLookup.set(
  "GameAlreadyOngoing",
  () => new GameAlreadyOngoingError(),
);

/**
 * GameAlreadyFinished: 'Game already finished'
 *
 * @category Errors
 * @category generated
 */
export class GameAlreadyFinishedError extends Error {
  readonly code: number = 0x1776;
  readonly name: string = "GameAlreadyFinished";
  constructor() {
    super("Game already finished");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameAlreadyFinishedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1776, () => new GameAlreadyFinishedError());
createErrorFromNameLookup.set(
  "GameAlreadyFinished",
  () => new GameAlreadyFinishedError(),
);

/**
 * GameAlreadySettled: 'Game already settled'
 *
 * @category Errors
 * @category generated
 */
export class GameAlreadySettledError extends Error {
  readonly code: number = 0x1777;
  readonly name: string = "GameAlreadySettled";
  constructor() {
    super("Game already settled");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameAlreadySettledError);
    }
  }
}

createErrorFromCodeLookup.set(0x1777, () => new GameAlreadySettledError());
createErrorFromNameLookup.set(
  "GameAlreadySettled",
  () => new GameAlreadySettledError(),
);

/**
 * NumericalOverflow: 'Numerical overflow'
 *
 * @category Errors
 * @category generated
 */
export class NumericalOverflowError extends Error {
  readonly code: number = 0x1778;
  readonly name: string = "NumericalOverflow";
  constructor() {
    super("Numerical overflow");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, NumericalOverflowError);
    }
  }
}

createErrorFromCodeLookup.set(0x1778, () => new NumericalOverflowError());
createErrorFromNameLookup.set(
  "NumericalOverflow",
  () => new NumericalOverflowError(),
);

/**
 * PlayerIsNotInGame: 'Player is not in game'
 *
 * @category Errors
 * @category generated
 */
export class PlayerIsNotInGameError extends Error {
  readonly code: number = 0x1779;
  readonly name: string = "PlayerIsNotInGame";
  constructor() {
    super("Player is not in game");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, PlayerIsNotInGameError);
    }
  }
}

createErrorFromCodeLookup.set(0x1779, () => new PlayerIsNotInGameError());
createErrorFromNameLookup.set(
  "PlayerIsNotInGame",
  () => new PlayerIsNotInGameError(),
);

/**
 * GameNotOngoing: 'Game is not ongoing'
 *
 * @category Errors
 * @category generated
 */
export class GameNotOngoingError extends Error {
  readonly code: number = 0x177a;
  readonly name: string = "GameNotOngoing";
  constructor() {
    super("Game is not ongoing");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameNotOngoingError);
    }
  }
}

createErrorFromCodeLookup.set(0x177a, () => new GameNotOngoingError());
createErrorFromNameLookup.set(
  "GameNotOngoing",
  () => new GameNotOngoingError(),
);

/**
 * GameNotFinished: 'Game is not finished'
 *
 * @category Errors
 * @category generated
 */
export class GameNotFinishedError extends Error {
  readonly code: number = 0x177b;
  readonly name: string = "GameNotFinished";
  constructor() {
    super("Game is not finished");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameNotFinishedError);
    }
  }
}

createErrorFromCodeLookup.set(0x177b, () => new GameNotFinishedError());
createErrorFromNameLookup.set(
  "GameNotFinished",
  () => new GameNotFinishedError(),
);

/**
 * PlayerProfileNotOfPlayer: 'Player profile not of player'
 *
 * @category Errors
 * @category generated
 */
export class PlayerProfileNotOfPlayerError extends Error {
  readonly code: number = 0x177c;
  readonly name: string = "PlayerProfileNotOfPlayer";
  constructor() {
    super("Player profile not of player");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, PlayerProfileNotOfPlayerError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x177c,
  () => new PlayerProfileNotOfPlayerError(),
);
createErrorFromNameLookup.set(
  "PlayerProfileNotOfPlayer",
  () => new PlayerProfileNotOfPlayerError(),
);

/**
 * SignerIsNotPlayer: 'Signer is not player'
 *
 * @category Errors
 * @category generated
 */
export class SignerIsNotPlayerError extends Error {
  readonly code: number = 0x177d;
  readonly name: string = "SignerIsNotPlayer";
  constructor() {
    super("Signer is not player");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, SignerIsNotPlayerError);
    }
  }
}

createErrorFromCodeLookup.set(0x177d, () => new SignerIsNotPlayerError());
createErrorFromNameLookup.set(
  "SignerIsNotPlayer",
  () => new SignerIsNotPlayerError(),
);

/**
 * WinnerNotWinner: 'Winner not winner'
 *
 * @category Errors
 * @category generated
 */
export class WinnerNotWinnerError extends Error {
  readonly code: number = 0x177e;
  readonly name: string = "WinnerNotWinner";
  constructor() {
    super("Winner not winner");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, WinnerNotWinnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x177e, () => new WinnerNotWinnerError());
createErrorFromNameLookup.set(
  "WinnerNotWinner",
  () => new WinnerNotWinnerError(),
);

/**
 * GameNotWaitingForPlayers: 'Game not waiting for players'
 *
 * @category Errors
 * @category generated
 */
export class GameNotWaitingForPlayersError extends Error {
  readonly code: number = 0x177f;
  readonly name: string = "GameNotWaitingForPlayers";
  constructor() {
    super("Game not waiting for players");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameNotWaitingForPlayersError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x177f,
  () => new GameNotWaitingForPlayersError(),
);
createErrorFromNameLookup.set(
  "GameNotWaitingForPlayers",
  () => new GameNotWaitingForPlayersError(),
);

/**
 * GameAlreadyStarted: 'Game already started'
 *
 * @category Errors
 * @category generated
 */
export class GameAlreadyStartedError extends Error {
  readonly code: number = 0x1780;
  readonly name: string = "GameAlreadyStarted";
  constructor() {
    super("Game already started");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameAlreadyStartedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1780, () => new GameAlreadyStartedError());
createErrorFromNameLookup.set(
  "GameAlreadyStarted",
  () => new GameAlreadyStartedError(),
);

/**
 * GameNotOnGoingOrWaitingForPlayers: 'Game not OnGoing or WaitingForPlayers'
 *
 * @category Errors
 * @category generated
 */
export class GameNotOnGoingOrWaitingForPlayersError extends Error {
  readonly code: number = 0x1781;
  readonly name: string = "GameNotOnGoingOrWaitingForPlayers";
  constructor() {
    super("Game not OnGoing or WaitingForPlayers");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameNotOnGoingOrWaitingForPlayersError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1781,
  () => new GameNotOnGoingOrWaitingForPlayersError(),
);
createErrorFromNameLookup.set(
  "GameNotOnGoingOrWaitingForPlayers",
  () => new GameNotOnGoingOrWaitingForPlayersError(),
);

/**
 * GameHashedLimitNotMatched: 'Game hashed limit not matched'
 *
 * @category Errors
 * @category generated
 */
export class GameHashedLimitNotMatchedError extends Error {
  readonly code: number = 0x1782;
  readonly name: string = "GameHashedLimitNotMatched";
  constructor() {
    super("Game hashed limit not matched");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameHashedLimitNotMatchedError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1782,
  () => new GameHashedLimitNotMatchedError(),
);
createErrorFromNameLookup.set(
  "GameHashedLimitNotMatched",
  () => new GameHashedLimitNotMatchedError(),
);

/**
 * GameAlreadyHasWinner: 'Game Already Has Winner'
 *
 * @category Errors
 * @category generated
 */
export class GameAlreadyHasWinnerError extends Error {
  readonly code: number = 0x1783;
  readonly name: string = "GameAlreadyHasWinner";
  constructor() {
    super("Game Already Has Winner");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameAlreadyHasWinnerError);
    }
  }
}

createErrorFromCodeLookup.set(0x1783, () => new GameAlreadyHasWinnerError());
createErrorFromNameLookup.set(
  "GameAlreadyHasWinner",
  () => new GameAlreadyHasWinnerError(),
);

/**
 * GameNotStarted: 'Game not started'
 *
 * @category Errors
 * @category generated
 */
export class GameNotStartedError extends Error {
  readonly code: number = 0x1784;
  readonly name: string = "GameNotStarted";
  constructor() {
    super("Game not started");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, GameNotStartedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1784, () => new GameNotStartedError());
createErrorFromNameLookup.set(
  "GameNotStarted",
  () => new GameNotStartedError(),
);

/**
 * WrongStatusForStartGame: 'Wrong status for start game'
 *
 * @category Errors
 * @category generated
 */
export class WrongStatusForStartGameError extends Error {
  readonly code: number = 0x1785;
  readonly name: string = "WrongStatusForStartGame";
  constructor() {
    super("Wrong status for start game");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, WrongStatusForStartGameError);
    }
  }
}

createErrorFromCodeLookup.set(0x1785, () => new WrongStatusForStartGameError());
createErrorFromNameLookup.set(
  "WrongStatusForStartGame",
  () => new WrongStatusForStartGameError(),
);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code);
  return createError != null ? createError() : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name);
  return createError != null ? createError() : null;
}
